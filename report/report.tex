\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}
\usepackage[latin1]{inputenc}

\sloppy

\title{Lottery scheduling on xv6 with basic statistical analysis}

\author{Gabriel Batista Galli\inst{1}}


\address{Federal University of Fronteira Sul (UFFS)\\
  Mailbox 181 -- 89.802-112 -- Chapecó -- SC -- Brazil
  \email{g7.galli96@gmail.com}}

\begin{document}

\maketitle

\begin{abstract}
This paper describes an implementation of the lottery scheduler in the
xv6 operating system. Lottery scheduling is a process scheduling
mechanism that randomly chooses a process to run based on its tickets
(just like a lottery). The more tickets one process have, the higher the
probability of it being chosen by the scheduler. In the code presented
here, the Binary Indexed Tree (BIT, or Fenwick Tree) is used to
efficiently count every process' amount of tickets. Then we analyze the
scheduler behavior by looking at what order a group of processes with
the same task, but different amounts of tickets, finish their job.
\end{abstract}

\section{Introduction}
The xv6 operating system is a simple Unix-like teaching operating
system developed by MIT and widely used in Operating Systems classes all
over the world. In our class, we were assigned to implement the
lottery scheduler on xv6, which initially had a basic First-In-First-Out
scheduler. Every time the scheduler was to choose a process to run, it
would linearly search through the array of processes looking for the
first process that is ready, starting at the previously used index.

The lottery scheduler is a probabilistic scheduler algorithm that works
similarly to a real world lottery. Every process is given a certain
amount of tickets and the scheduler randomly picks one of the available
tickets among all processes. The process holding the chosen ticket is
then picked to be run by the processor in the next quantum. This way, we
can think of a process that have a high quantity of tickets as having a
high priority, as it has a high probability of being chosen by the
scheduler and it will thus be run more frequently than a process that
have less tickets.

\section{The lottery scheduler} \label{sec:lottsched}
In order to implement the lottery scheduler, a few changes were needed in
some data structures used by xv6. The first modification was in the
\texttt{proc} structure, found in the \texttt{proc.h} file, in which it
was added the \texttt{tickets} attribute to hold the quantity of tickets a process was given.

\begin{scriptsize}
\begin{verbatim}
// Per-process state
struct proc {
  uint sz;                     // Size of process memory (bytes)
  pde_t* pgdir;                // Page table
  char *kstack;                // Bottom of kernel stack for this process
  enum procstate state;        // Process state
  int pid;                     // Process ID
  struct proc *parent;         // Parent process
  struct trapframe *tf;        // Trap frame for current syscall
  struct context *context;     // swtch() here to run process
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
  int tickets;                 // Quantity of tickets assigned to this process
};
\end{verbatim}
\end{scriptsize}

Some other modifications made in the code relate to the \texttt{ptable}
structure, found in the \texttt{proc.c} file: the \texttt{deadstack}
array (a stack), its \texttt{top} and the \texttt{tickets} array:

\begin{scriptsize}
\begin{verbatim}
struct {
  int deadstack[NPROC], top;
  int tickets[NPROC + 1];
  struct spinlock lock;
  struct proc proc[NPROC];
} ptable;
\end{verbatim}
\end{scriptsize}

The \texttt{deadstack} array is a stack of the currently available
\texttt{pid}s. When xv6 starts and the function \texttt{pinit} is
called, \texttt{deadstack} will be initialized with all \texttt{pid}s
from NPROC to 1 (so the \texttt{pid} 1 will be at the top, and
the value of \texttt{top} will end up being equal to
\texttt{NPROC}). Then, whenever a new process is created, it will be
identified by the \texttt{pid} found on top of \texttt{deadstack}. Similarly, when a
process dies and its position in the \texttt{proc} array is once again set to
\texttt{UNUSED}, the \texttt{pid} that was being used by that process is
given back to the top of \texttt{deadstack} so it can be used
again.

To keep track of every process' tickets, the \texttt{tickets} array was
created to be used as a Binary Indexed Tree (BIT, also known as Fenwick
Tree) to efficiently count how many tickets there are up until a given
process (among all existing processes). This way, we can binary search
our tree until we find the leftmost position in the array that
sums greater than or equal to the ticket that was picked this time
around. This position in the BIT is the chosen process \texttt{pid} and,
because of the \texttt{deadstack} way of handling \texttt{pid}s, it is
also its position in the \texttt{proc} array. To manipulate the BIT, the functions \texttt{uptick} and
\texttt{ticount} are used. The former updates the BIT whenever a process is
created, executed or exits and the latter returns the sum of tickets up
intil a given position. Just as \texttt{deadstack}, \texttt{proc} is
initialized in the \texttt{pinit} function, where all positions are set
to 0.

\subsection{Updating the BIT}
As said before, \texttt{uptick} is used to update the BIT whenever a
process is created, executed or exits. It is critical that we
don't call it any time more or less than needed, as the BIT will end up
accumulating a wrong amount of tickets or one process will be considered
to have more tickets than it actually does.

\texttt{uptick} is then called in the functions that initialize a
process: \texttt{userinit}, \texttt{fork}; when a process is chosen to
be executed: \texttt{scheduler}; when a process gives up the processor
because its time is over: \texttt{yield}; when a process is woken up:
\texttt{wakeup1}, called by \texttt{wakeup}; and when a process is killed
and we have to wake up the parent, if it is sleeping, so it
\texttt{wait} for that process to \texttt{exit}: \texttt{kill}.

\section{References}

Bibliographic references must be unambiguous and uniform.  We recommend giving
the author names references in brackets, e.g. \cite{knuth:84},
\cite{boulic:91}, and \cite{smith:99}.

The references must be listed using 12 point font size, with 6 points of space
before each reference. The first line of each reference should not be
indented, while the subsequent should be indented by 0.5 cm.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
